# 概述
* 性能是主观的，可以使用一些客观的目标来衡量，比如目标吞吐量，目标平均响应时延，目标cpu占用，目标中断频次。 通常采用的做法是对业务流程进行建模，获得全局视角，有了整体视角后，围绕吞吐量，占用率，延迟，速率等指标进行优化，优化的手段包括 zero copy, 异步，并行化，绑核，合并等。

*  优化目标
    - 延迟：完成某一个操作或者请求的时间
    - 占用率：某项资源在一段时间内的繁忙程度
    - 吞吐量：每秒传输的数据量
    - 速率：每秒操作或者请求的速率

* 面向业务流的优化手段
    - zero copy: 减少内存拷贝。通常内存拷贝可以实现数据隔离，实现逻辑解耦合。但是对性能不友好，实现zero copy优化的时候需要注意同步，异步模型。因为拷贝一块内存是一种异步模型。
        -重构软件模型，增加缓存机制
        -使用锁机制处理好竞态区域，解决内存拷贝的诉求
        -使用zero copy的系统调用（soceket recv/send zero copy flag),mmap
        -优点：减少cpu占用，增加吞吐量，减少延时。缺点：增加程序的复杂度
    - 并行化：让各个component最大负载工作（减少空闲时间），增加整个pipeline的处理带宽。
        -多线程，各级buffer机制，
        -如果component是独立的硬件单元并且处理时间较长的时候，可以使用并行化的手段，如果component只是一个软件算法逻辑，并且执行单元是cpu，将其并行化还要注意contex切换的消耗。
        -优点：增加吞吐量，缺点：程序复杂度增加
    - 异步：某种程度上也是并行化的一种方式，这里只讨论io异步处理
        -增加缓存机制，FIFO，ring buffer,空满队列
        -隔离生产者和消费者的处理流，划分提交队列（SQ)与完成队列（CQ）
        -优点：增加吞吐量，当生产者消费者性能不稳定的时候，有效的抗抖动手段
        -缺点：增加程序的复杂度，可能需要额外的内存空间用于缓存
    - 绑核：设置进程cpu affinity,设置中断affinity。
    - 合并：针对硬件的特性，合并处理单元，发挥最大的io性能（IO合并）。
    
* 在进行优化分析之前，要对模型进行建模和流程分析，找出系统的瓶颈和问题所在，liunx的tracing技术可以帮助我们进行目标业务流的建模以及找出模型的关键指标。

# linux tracing技术

## kprobe/kretprobe
* 提供在内核态动态添加探针的方式，使用前确定内核config打开，CONFIG_KPROBE_EVENT=y
* 使用场景：查看函数的调用频次和执行时间。查看函数调用的参数和返回值。

### 基本原理：替换目标指令为brk（arm架构）,以此陷入到kprobe机制中。
* 用户通过int register_kprobe(struct kprobe \*p)注册一个探测点，在注册的过程中，kprobe机制会通过用户传入的symbol名称找到其对应的指令地址，并且将指令地址和具体的指令备份到kprobe结构的addr和opcode属性中，然后将kprobe插入到kprobe_table中。最后将原始指令的入口点替换为BRK指令，并且将BRK指令的立即数设置为0x4或者0x6。用来表示本次trap由kprobe机制触发。
* 


